import { appendChild, attr, bindAttr, bindEvent, docFragment, element, remove, text } from "./core.js";
import { isReactive } from "./store.js";
import { applyAll, err, isFunction, isObject, noop, push, __DEV__ } from "./util.js";
const addChild = (child, attach) => {
    if (child instanceof Node) {
        attach(child);
        return () => {
            remove(child);
        };
    }
    if (isFunction(child)) {
        return child(attach)[0];
    }
    return text `${child}`(attach);
};
const renderChild = (children, _attach) => {
    let begin = null, end = null;
    const attach = (node) => {
        const isFragment = node instanceof DocumentFragment;
        if (!begin) {
            if (isFragment) {
                begin = node.firstChild;
            }
            else {
                begin = node;
            }
        }
        if (isFragment) {
            end = node.lastChild;
        }
        else {
            end = node;
        }
        return _attach(node);
    };
    const cleanups = [];
    if (Array.isArray(children)) {
        for (const child of children) {
            push(cleanups, addChild(child, attach));
        }
    }
    else {
        push(cleanups, addChild(children, attach));
    }
    return [cleanups, () => (begin && end ? [begin, end] : void 0)];
};
const pattern = /^on[A-Z]/;
const isEventAttribute = (name) => pattern.test(name);
export const jsx = (type, props) => {
    if (typeof type === "string") {
        return (attach) => {
            const el = element(type);
            const { children, ref, ...attributes } = props;
            if (ref) {
                ref.el = el;
            }
            const [cleanups] = children != null ? renderChild(children, appendChild(el)) : [[]];
            for (const [key, value] of Object.entries(attributes)) {
                if (isObject(value)) {
                    if (__DEV__ && !isReactive(value)) {
                        err(`The given value '${JSON.stringify(value)}' for attribute ${key} is not a reactive source/query.`);
                    }
                    push(cleanups, bindAttr(el, key, value));
                }
                else if (isFunction(value) && isEventAttribute(key)) {
                    const host = bindEvent(el);
                    push(cleanups, host(key.slice(2).toLowerCase(), value));
                }
                else {
                    attr(el, key, value);
                }
            }
            push(cleanups, () => remove(el));
            attach(el);
            return [applyAll(cleanups), el, () => [el, el]];
        };
    }
    // @ts-expect-error Dynamic Implementation
    return type(props);
};
export const jsxs = jsx;
/**
 * Create a jsx ref object to fetch the DOM element when mounted.
 */
export const jsxRef = () => ({
    el: null,
});
export const Fragment = ({ children }) => {
    return (attach) => {
        const fragment = docFragment();
        const [cleanups, getRange] = children ? renderChild(children, appendChild(fragment)) : [[], noop];
        attach(fragment);
        return [applyAll(cleanups), void 0, getRange];
    };
};
//# sourceMappingURL=jsx-runtime.js.map