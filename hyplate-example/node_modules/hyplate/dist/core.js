import { err, __DEV__ } from "./util.js";
import { isReactive, subscribe } from "./store.js";
import { applyAll, isObject, isString, push } from "./util.js";
import { comment } from "./internal.js";
export const element = document.createElement.bind(document);
export const docFragment = document.createDocumentFragment.bind(document);
export const clone = (node) => node.cloneNode(true);
export const attr = (element, name, value) => value == null || value === false ? element.removeAttribute(name) : element.setAttribute(name, `${value}`);
export const select = (host, selecor) => isString(host) ? document.querySelector(host) : host.querySelector(selecor);
export const anchorRef = (p1, p2) => {
    if (isString(p1)) {
        return document.querySelector(`template[\\#${p1}]`);
    }
    return p1.querySelector(`[\\#${p2}]`);
};
export const $ = anchorRef;
export const $$ = (host, selector) => Array.from(host.querySelectorAll(selector));
export const bindText = (node, query) => subscribe(query, (text) => (node.textContent = `${text}`));
export const text = (fragments, ...bindings) => {
    const fragmentsLength = fragments.length;
    const bindingsLength = bindings.length;
    if (__DEV__) {
        if (fragmentsLength !== bindingsLength + 1) {
            err(`Invalid usage of "text". Fragments length(${fragments.length}) and bindings length(${bindings.length}) do not match.`);
        }
        if (bindings.some((binding) => isObject(binding) && !isReactive(binding))) {
            err(`Invalid usage of "text". Object text child must be reactive source/query.`);
        }
    }
    return (attach) => {
        const effects = [];
        const buf = [];
        const flushBuf = () => {
            const textContent = buf.join("");
            if (textContent) {
                const textNode = new Text(textContent);
                push(effects, () => remove(textNode));
                attach(textNode);
            }
            buf.length = 0;
        };
        for (let i = 0; i < bindingsLength; i++) {
            push(buf, fragments[i]);
            const expression = bindings[i];
            if (isObject(expression)) {
                flushBuf();
                const dynamicText = new Text();
                push(effects, bindText(dynamicText, expression));
                push(effects, () => remove(dynamicText));
                attach(dynamicText);
            }
            else {
                push(buf, `${expression}`);
            }
        }
        push(buf, fragments.at(-1));
        flushBuf();
        return applyAll(effects);
    };
};
export const bindAttr = (el, name, query) => subscribe(query, (attribute) => attr(el, name, attribute));
export const bindEvent = (target) => (name, handler, options) => {
    // @ts-expect-error generic
    target.addEventListener(name, handler, options);
    return () => {
        // @ts-expect-error generic
        target.removeEventListener(name, handler, options);
    };
};
export const appendChild = (host) => (node) => (host.appendChild(node), host);
export const before = (element) => (node) => (element.before(node), element.parentElement);
export const after = (element) => (node) => (element.after(node), element.parentElement);
export const seqAfter = (element) => {
    const begin = comment(" sequence after begin ");
    const end = comment(" sequence after end ");
    const append = after(element);
    append(begin);
    append(end);
    const insert = before(end);
    return insert;
};
export const remove = (node) => node.remove();
export const moveRange = (begin, end) => (attach) => {
    const targets = [];
    for (let node = begin; node && node !== end; node = node.nextSibling) {
        push(targets, node);
    }
    if (end) {
        push(targets, end);
    }
    for (const node of targets) {
        attach(node);
    }
};
export const insertSlot = (host, slotName, element) => {
    attr(element, "slot", slotName);
    appendChild(host)(element);
};
//# sourceMappingURL=core.js.map