import { bindEvent, anchorRef, select } from "./core.js";
import { once, scopes } from "./util.js";
/**
 * @internal
 */
export const [enterHooks, quitHooks, _resolveHooks] = scopes();
const resolveHooks = () => {
    let currentHooks = _resolveHooks();
    if (!currentHooks) {
        throw new Error(`Invalid hook call. Hooks can only be called inside the setup function of template-based component.`);
    }
    return currentHooks;
};
export const createHooks = ({ host, parent }) => {
    const cleanups = new Set();
    const effect = (cleanup) => {
        const wrapped = once(() => {
            cleanups.delete(wrapped);
            cleanup();
        });
        cleanups.add(wrapped);
        return wrapped;
    };
    const useCleanUpCollector = () => effect;
    const useHost = () => host;
    const useParent = () => parent;
    const hooks = {
        useCleanUpCollector,
        useHost,
        useParent,
    };
    const cleanup = () => {
        for (const cleanup of [...cleanups]) {
            cleanup();
        }
        cleanups.clear();
    };
    return [hooks, cleanup];
};
export const useCleanUpCollector = () => resolveHooks().useCleanUpCollector();
export const useHost = () => resolveHooks().useHost();
export const useParent = () => resolveHooks().useParent();
export const useAnchor = (hid) => anchorRef(useHost(), hid);
export const useChildView = (mountable) => (attach) => {
    const [cleanup, exposed] = mountable(attach);
    useCleanUp(cleanup);
    return exposed;
};
export const useCleanUp = (cleanup) => resolveHooks().useCleanUpCollector()(cleanup);
export const useEvent = (target) => {
    const eventHost = bindEvent(target);
    const effect = resolveHooks().useCleanUpCollector();
    return (name, handler, options) => {
        const cleanup = effect(eventHost(name, handler, options));
        return cleanup;
    };
};
export const useRef = (selecor) => select(useHost(), selecor);
//# sourceMappingURL=hooks.js.map