const t=Object.assign,e=t=>{let e,s=!1;return()=>s?e:(s=!0,e=t())},s=()=>{const t=[];return[e=>n(t,e),()=>{a(t)},()=>t.at(-1)]},n=(t,e)=>t.push(e),a=t=>t.pop(),r=()=>{},o=t=>()=>{for(const e of t)e()},c=t=>"string"==typeof t,f=t=>"function"==typeof t,l=t=>null!=t&&"object"==typeof t,u=Object.is,g=(t,e)=>e;
/**
 * @license MIT
 * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
let p=u;const d=t=>{p=t??u},[i,h,w]=s(),y=(t,e=p)=>{const s={get val(){return w()?.(s),t},set(n){e(t,n)||(t=n,O(s,n))}};return b.set(s,new Set),s},b=new WeakMap,j=t=>b.has(t),k=(t,s)=>(b.get(t).add(s),s(t.val),e((()=>{b.get(t).delete(s)}))),O=(t,e)=>{[...b.get(t)].forEach((t=>{try{t(e)}catch(t){(t=>{const e=t instanceof Error?`stack trace: \n${t.stack}`:JSON.stringify(t);console.error(`[ERROR]: ${e}`)})(t)}}))},S=(t,e=p)=>{const s={get val(){return o(),a}};let n=!0,a=null,r=[];const o=()=>{if(w()?.(s),!n)return;n=!1;const[e,o]=(()=>{const t=new Set;return i((e=>{t.add(e)})),[t,()=>{h()}]})();a=t(),o();for(const t of r)t();r=[...e].map((t=>{const e=b.get(t);return e.add(c),()=>{e.delete(c)}}))},c=()=>{n=!0;const t=a;o(),e(t,a)||O(s,a)};return b.set(s,new Set),s};export{y as a,k as b,l as c,o as d,f as e,u as f,s as g,t as h,c as i,j,O as k,r as n,e as o,n as p,S as q,d as s,g as w};
