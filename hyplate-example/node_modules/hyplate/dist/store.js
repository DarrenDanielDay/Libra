/**
 * @license MIT
 * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { compare, err, __DEV__ } from "./util.js";
import { once, scopes } from "./util.js";
let defaultDiffer = compare;
export const setDiffer = (differ) => {
    defaultDiffer = differ ?? compare;
};
const [enterScope, quitScope, currentScope] = scopes();
const useDepScope = () => {
    const deps = new Set();
    enterScope((src) => {
        deps.add(src);
    });
    return [
        deps,
        () => {
            quitScope();
        },
    ];
};
export const source = (val, differ = defaultDiffer) => {
    const src = {
        get val() {
            currentScope()?.(src);
            return val;
        },
        set(newVal) {
            if (differ(val, newVal)) {
                return;
            }
            val = newVal;
            dispatch(src, newVal);
        },
    };
    subscriptions.set(src, new Set());
    return src;
};
const subscriptions = new WeakMap();
if (__DEV__) {
    Object.assign(globalThis, { __SUBSCRIPTIONS__: subscriptions });
}
/**
 * @internal
 */
export const isReactive = (obj) => 
// @ts-expect-error contravariance
subscriptions.has(obj);
export const subscribe = (query, subscriber) => {
    subscriptions.get(query).add(subscriber);
    subscriber(query.val);
    return once(() => {
        subscriptions.get(query).delete(subscriber);
    });
};
export const dispatch = (src, newVal) => {
    [...subscriptions.get(src)].forEach((sub) => {
        try {
            sub(newVal);
        }
        catch (error) {
            err(error);
        }
    });
};
export const query = (selector, differ = defaultDiffer) => {
    const q = {
        get val() {
            lazyEvaluate();
            return current;
        },
    };
    let dirty = true;
    let current = null;
    let teardowns = [];
    const lazyEvaluate = () => {
        currentScope()?.(q);
        if (!dirty) {
            return;
        }
        dirty = false;
        const [newDeps, cleanupDepScope] = useDepScope();
        current = selector();
        cleanupDepScope();
        for (const unsubscribe of teardowns) {
            unsubscribe();
        }
        teardowns = [...newDeps].map((dep) => {
            const subscribers = subscriptions.get(dep);
            subscribers.add(queryDispatch);
            return () => {
                subscribers.delete(queryDispatch);
            };
        });
    };
    const queryDispatch = () => {
        dirty = true;
        const last = current;
        lazyEvaluate();
        if (differ(last, current)) {
            return;
        }
        dispatch(q, current);
    };
    subscriptions.set(q, new Set());
    return q;
};
//# sourceMappingURL=store.js.map